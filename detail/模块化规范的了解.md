## 模块规范了解

> 对各种规范的回顾

1. commonJs
   - 所有代码都运行在模块作用域，不会污染全局作用域
   - 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
   - 模块加载的顺序，按照其在代码中出现的顺序。

> ​	实际操作：`module.exports`与`require`；
>
> > 为了方便，nodeJs为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令在node里`var export = module.exports`

2. AMD  ** Asynchronous Module Definition**
   - AMD是一种浏览器端模块化开发的规范
   - AMD也采用require()语句加载模块，但不同于commonJs，AMD的require需要传两个参数`require([module], callback)`
   - 优点：适合在浏览器环境中异步加载模块。可以并行加载多个模块
   - 缺点：不能按需加载，而是必须提前加载所有的依赖

> RequireJS是一个工具库，主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守**AMD规范**

3. CMD ** Common Module Definition **
   - CMD 主要依赖就近
   - CMD 是延迟执行
   - 可按需加载

> CMD是SeaJS 在推广过程中对模块定义的规范化产出

4. ES6模块
   - ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入
   - ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量

>  CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案

##### 部分比较

- AMD与CommonJs

> CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。
>
> 由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范

- AMD与CMD

> AMD推崇依赖前置（在定义模块的时候就要声明其依赖的模块），CMD推崇依赖就近（只有在用到某个模块的时候再去require——按需加载）

##### 附加

- [webpack中的加载机制](https://segmentfault.com/a/1190000013630936)

